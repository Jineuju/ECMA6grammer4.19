/*
어떤 코드를 바로 실행하지 않고 일정 시간 딜레이한 후에 실행해야하는 경우가 있습니다.
이럴때는 setTimeout이라는 내장함수를 사용합니다
첫번째 인수 : 콜백함수, 두번째 인수 : 시간(밀리초단위)
setTimeout(콜백함수, 시간);
*/

setTimeout(() => console.log("2초 후에 실행됩니다"), 2000);

function test(delay, callback) {
  setTimeout(() => {
    callback();
  }, delay);
}

// test라고하는 함수는 두가지의 인수를 받아서 setTimeout을 호출하는 함수입니다

// test(() => {
//   console.log("콜백");
// }, 1000);

/*
동기식 방식 vs 비동기식 방식

동기식 : 직렬형으로 A가 끝나야지만 B를 처리할 수 있음(대략적으로 일을 처리하는데 시작 시간과 끝나는 시간을 예측가능)
비동기식 : 병렬형으로 작업에 참여하는 주체만큼 동시에 작업을 시작할 수 있음(어떤 주체가 언제 일이 끝날지 예상되는 시간을 예측 불가)

따라서 반드시 a작업이 마치고 b작업이 실행되어야하는 경우 무조건 "동기식"으로 처리해야합니다
*/

// 순서1. 스타트 콘솔 문이 실행됩니다(js안에서)
// console.log("start");

// // 순서2. test함수를 호출(js) => setTimeout구문이 web api에 전달(js)
// test(() => {
//   console.log("콜백1"); // 순서6. setTimeout을 처리하고 그 안쪽에서 콜백으로
//   // 정의한 콘솔문이 js에 전달됩니다(web api)
// }, 0);

// // 순서3. test함수를 호출(js) => setTimeout구문이 webapi에 전달(js)
// test(() => {
//   console.log("콜백2"); // 순서7. setTimeout을 처리하고 그 안쪽에서 콜백으로
//   // 정의한 콘솔문이 js에 전달됩니다(web api)
// }, 0);

// // 순서4. test함수를 호출(js) => setTimeout구문이 webapi에 전달(js)
// test(() => {
//   console.log("콜백3"); // 순서8. setTimeout을 처리하고 그 안쪽에서 콜백으로
//   // 정의한 콘솔문이 js에 전달됩니다(web api)
// }, 0);
// // 순서5. 앤드 콘솔문이 실행됩니다
// console.log("end");

/*
위의 코드가 만약 자바스크립트 엔진에서만 작동하는 작업이라면 당연히 동기적으로 실행되어
예상하는 대로 "스타트" "테스트함수들" "엔드"가 작업결과가 되겠지만
셋타임아웃을 호출하는 함수인 test함수를 작업하기 때문에 web API와 분담하는 작업이 됩니다
따라서 비동기적으로 작동할 수 밖에 없는 구조입니다
*/

console.log("start");

test(2000, () => {
  console.log("콜백1");
  test(2000, () => {
    console.log("콜백2");
    test(2000, () => {
      console.log("콜백3");
      console.log("end");
    });
  });
});

/*
콜백함수 : 함수가 종료되는 시점에 다시 함수를 호출하여서 동기적으로 실행될 수 있게 하는 방법
단점 : 코드가 난잡하고, 보기 불편해서 유지 보수성도 없어 쓰기 불편하다

하지만 콜백은 그러함에도 불구하고 사용합니다. 단, 복잡한 코드에서는 다른 방법을 사용하고
단순 그 다음으로 연결된 동기적인 상황에서는 콜백을 애용합니다

따라서 
동기적 작동 방식 1단계 : 콜백함수
2단계 : promise
3단계 : async await
*/
